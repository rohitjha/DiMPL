{-
-------------------------------
| NumberTheory Module for MPL |
-------------------------------

Functionality for:
	-> 

Author: Rohit Jha
Version: 0.0.1
Date: 26 Dec 2012
-}


module MPL.NumberTheory.NumberTheory where


d `divides` n = n `mod` d == 0


n `splitWith` p = doSplitWith 0 n
	where doSplitWith s t
		| p `divides` t = doSplitWith (s+1) (t `div` p)
		| otherwise     = (s, t)


power (idG,multG) x n = doPower idG x n
	where
		doPower y _ 0 = y
		doPower y x n =
			let y' = if odd n then (y `multG` x) else y
			    x' = x `multG` x
			    n' = n `div` 2
			in doPower y' x' n'


minus (x:xs) (y:ys) = case (compare x y) of 
           LT -> x : minus  xs  (y:ys)
           EQ ->     minus  xs     ys 
           GT ->     minus (x:xs)  ys
minus  xs     _     = xs


primesTo 0 = []
primesTo 1 = []
primesTo 2 = [2]
primesTo m = 2 : sieve [3,5..m]  where
    sieve (p:xs) 
       | p*p > m   = p : xs
       | otherwise = p : sieve (xs `minus` [p*p, p*p+2*p..])


nPrimes n = take n (sieve [2..])
	where sieve (p:ns) = p : sieve (filter (notdiv p) ns)
	      notdiv p n = n `mod` p /= 0


primesTo100 :: [Integer]
primesTo100 = [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97]


trialDivision ps n = doTrialDivision ps
	where doTrialDivision (p:ps) = let (q,r) = n `quotRem` p in if r == 0 then False else if q < p then True else doTrialDivision ps
	      doTrialDivision [] = True


primesTo10000 = primesTo100 ++ filter (trialDivision primesTo100) [101,103..9999]


isTrialDivisionPrime 2 = True
isTrialDivisionPrime n = trialDivision (primesTo10000 ++ [10001,10003..]) n


isStrongPseudoPrime :: Integer -> (Int,Integer) -> Integer -> Bool
isStrongPseudoPrime n (s,t) b =
	-- let b' = powerMod n b t
	let b' = power (1, \x y -> x*y `mod` n) b t
	in if b' == 1 then True else doSquaring s b'
	where
		doSquaring 0 x = False
		doSquaring s x
			| x == n-1  = True
			| x == 1    = False
			| otherwise = doSquaring (s-1) (x*x `mod` n)


isMillerRabinPrime :: Integer -> Bool
isMillerRabinPrime n
	| n < 100   = n `elem` primesTo100
	| otherwise = all (isStrongPseudoPrime n (s,t)) primesTo100
		where (s,t) = (n-1) `splitWith` 2


isPrime :: Integer -> Bool
isPrime n
	| n < 2          = False
	| n < 500000000  = isTrialDivisionPrime n
	| n >= 500000000 = isMillerRabinPrime n


nextPrime :: Integer -> Integer
nextPrime n = head [p | p <- [n..], isPrime p]


primePowerFactors :: Integer -> [(Integer,Int)]
primePowerFactors n | n > 0 = takeOutFactors n primesTo10000
	where
		takeOutFactors n (p:ps)
--			| n == 1    = [] -- unnecessary, caught by following test
			| p*p > n   = finish n
			| otherwise =
				let (s,n') = n `splitWith` p
				in if s > 0 then (p,s) : takeOutFactors n' ps else takeOutFactors n ps
		takeOutFactors n [] = finish n
		finish 1 = []
		finish n =
			if n < 100000000 || isMillerRabinPrime n -- we already know it's a trial division prime up to 10000
			then [(n,1)]
			else error ("primePowerFactors: unable to factor " ++ show n)


primeFactors :: Integer -> [Integer]
primeFactors n = concat (map (\(p,a) -> replicate a p) (primePowerFactors n))


fib n = round $ phi ** fromIntegral n / sq5
	where
		sq5 = sqrt 5 :: Double
		phi = (1 + sq5) / 2


fibList = 0 : 1 : zipWith (+) fibs (tail fibs)


fibUpto n = take n fibList
